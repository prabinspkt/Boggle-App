{"version":3,"sources":["create_random_grid.js","boggle_solver.js","index.js"],"names":["RandomGrid","chars","map","cube","Math","floor","random","length","sort","grid","row","col","gridNode","letter","this","visited","indices","adjacencyList","push","verifyWord","word","wordIndex","gridNodes","listExhausted","nodeIndex","wordFound","adjacentNodeIndex","gridNodeIndex","indexToAdd","isEqual","nodeLetterIndex","charAt","toUpperCase","findAllSolutions","dictionary","foundWords","colNum","width","height","adjacencyLists","newNode","addAdjacentIndex","generateAdjacencyLists","PrintGrid","grid_data","props","Card","className","Body","Title","Text","class","ButtonToolbar","Button","variant","React","Component","PrintList","print_items_list","print_words","print_item","valid_invalid","GamePlay","state","random_grid","grid_solutions","random_grid_solutions","input_word","valid_words","invalid_words","ongoing","handleChange","bind","handleSubmit","handleStop","event","setState","target","value","preventDefault","toLowerCase","has","includes","alert","new_valid_words","remaining_words","delete","new_invalid_words","validated_word","console","log","onSubmit","type","onChange","onClick","Array","from","Game","show_grid","all_words","words","random_grid_solutions_set","Set","Header","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.bce28bf5.chunk.js","sourcesContent":["// Returns a random 5x5 board, using the official letter distribution.\nconst RandomGrid = () => {\n  // prettier-ignore\n  const dice = [\"AAAFRS\", \"AAEEEE\", \"AAFIRS\", \"ADENNN\", \"AEEEEM\",\n                  \"AEEGMU\", \"AEGMNN\", \"AFIRSY\", \"BJKQXZ\", \"CCNSTW\",\n                  \"CEIILT\", \"CEILPT\", \"CEIPST\", \"DHHNOT\", \"DHHLOR\",\n                  \"DHLNOR\", \"DDLNOR\", \"EIIITT\", \"EMOTTT\", \"ENSSSU\",\n                  \"FIPRSY\", \"GORRVW\", \"HIPRRY\", \"NOOTUW\", \"OOOTTU\"];\n  let chars = dice.map(cube => cube[Math.floor(Math.random() * cube.length)]);\n  chars.sort(() => Math.random() - 0.5); // Shuffle the letters.\n\n  const SIZE = 5;\n  let grid = [];\n  for (let row = 0; row < SIZE; row++) {\n    grid[row] = [];\n    for (let col = 0; col < SIZE; ++col) {\n      grid[row][col] = chars[SIZE * row + col];\n      if (grid[row][col] === 'Q') grid[row][col] = 'Qu';\n    }\n  }\n  return grid;\n};\n\nexport default RandomGrid;\n","// Grid nodes that represent nodes in the grid provided.\nclass gridNode {\n  constructor(row, col, letter) {\n    this.visited = false;\n    this.indices = [row, col];\n    this.letter = letter;\n    this.adjacencyList = [];\n  }\n  addAdjacentIndex(row, col) {\n    this.adjacencyList.push([row, col]);\n  }\n}\n\n// Returns a list that contains the grid nodes and their adjacency lists.\nfunction generateAdjacencyLists(width, height, grid) {\n  var adjacencyLists = [];\n  for (var row = 0; row < width; row++) {\n    for (var col = 0; col < height; col++) {\n      var newNode = new gridNode(row, col, grid[row][col]);\n\n      if (row > 0) {\n        newNode.addAdjacentIndex(row - 1, col);\n      }\n      if (row < width - 1) {\n        newNode.addAdjacentIndex(row + 1, col);\n      }\n      if (col > 0) {\n        newNode.addAdjacentIndex(row, col - 1);\n      }\n      if (col < height - 1) {\n        newNode.addAdjacentIndex(row, col + 1);\n      }\n      if (row > 0 && col > 0) {\n        newNode.addAdjacentIndex(row - 1, col - 1);\n      }\n      if (row > 0 && col < height - 1) {\n        newNode.addAdjacentIndex(row - 1, col + 1);\n      }\n      if (row < width - 1 && col > 0) {\n        newNode.addAdjacentIndex(row + 1, col - 1);\n      }\n      if (row < width - 1 && col < height - 1) {\n        newNode.addAdjacentIndex(row + 1, col + 1);\n      }\n\n      adjacencyLists.push(newNode);\n    }\n  }\n  return adjacencyLists;\n}\n\n// Verifies whether the word provided can be found in the grid.\nfunction verifyWord(adjacencyList, word, wordIndex, gridNodes) {\n  if (wordIndex >= word.length) {\n    return true;\n  }\n\n  // Checks whether all nodes have been visited or not.\n  var listExhausted = true;\n  for (let nodeIndex = 0; nodeIndex < gridNodes.length; nodeIndex++) {\n    if (gridNodes[nodeIndex].visited === false) {\n      listExhausted = false;\n      break;\n    }\n  }\n  if (listExhausted) {\n    return false;\n  }\n\n  // This part of the code checks whether the current character of the word matches any of the nodes in the nodelist that is adjacent to the current node. Then, repeats recursively.\n  var wordFound = false;\n  for (\n    var adjacentNodeIndex = 0;\n    adjacentNodeIndex < adjacencyList.length;\n    adjacentNodeIndex++\n  ) {\n    for (\n      var gridNodeIndex = 0;\n      gridNodeIndex < gridNodes.length;\n      gridNodeIndex++\n    ) {\n      // The following if statement is to check whether the current grid node is indeed the adjacent node that is currently being processed.\n      // This is done by checking the indices of both nodes (at both row index and column index).\n      if (\n        adjacencyList[adjacentNodeIndex][0] ===\n          gridNodes[gridNodeIndex].indices[0] &&\n        adjacencyList[adjacentNodeIndex][1] ===\n          gridNodes[gridNodeIndex].indices[1]\n      ) {\n        var indexToAdd = 0;\n        var isEqual = true;\n        for (\n          var nodeLetterIndex = 0;\n          nodeLetterIndex < gridNodes[gridNodeIndex].letter.length;\n          nodeLetterIndex++\n        ) {\n          if (\n            word.charAt(wordIndex + indexToAdd).toUpperCase() !==\n            gridNodes[gridNodeIndex].letter\n              .charAt(nodeLetterIndex)\n              .toUpperCase()\n          ) {\n            isEqual = false;\n          }\n          indexToAdd += 1;\n        }\n\n        if (gridNodes[gridNodeIndex].visited === false && isEqual) {\n          gridNodes[gridNodeIndex].visited = true;\n          wordFound =\n            wordFound ||\n            verifyWord(\n              gridNodes[gridNodeIndex].adjacencyList,\n              word,\n              wordIndex + indexToAdd,\n              gridNodes\n            );\n          gridNodes[gridNodeIndex].visited = false;\n        }\n      }\n    }\n  }\n  return wordFound;\n}\n\n// This function finds all dictionary words that exist in the grid.\nexport const findAllSolutions = (grid, dictionary) => {\n  var foundWords = [];\n  // Check for invalid inputs.\n  if (!grid || !dictionary) {\n    return foundWords;\n  }\n\n  if (grid.length === 0 || grid[0].length === 0) {\n    return foundWords;\n  }\n\n  // Check for inconsistent column numbers within grid.\n  var colNum = grid[0].length;\n  for (var row = 1; row < grid.length; row++) {\n    if (grid[row].length !== colNum) {\n      return foundWords;\n    }\n  }\n\n  // Generate adjacency lists for all grid nodes.\n  var gridNodes = generateAdjacencyLists(grid.length, grid[0].length, grid);\n\n  for (var wordIndex = 0; wordIndex < dictionary.length; wordIndex++) {\n    // Only check for word if length is >= 3.\n    if (dictionary[wordIndex].length < 3) {\n      continue;\n    }\n\n    // Check for the first word character match before moving onto the recursive function to check the word match.\n    for (\n      var gridNodeIndex = 0;\n      gridNodeIndex < gridNodes.length;\n      gridNodeIndex++\n    ) {\n      var indexToAdd = 0;\n      var isEqual = true;\n      for (\n        var nodeLetterIndex = 0;\n        nodeLetterIndex < gridNodes[gridNodeIndex].letter.length;\n        nodeLetterIndex++\n      ) {\n        if (\n          dictionary[wordIndex].charAt(0 + indexToAdd).toUpperCase() !==\n          gridNodes[gridNodeIndex].letter.charAt(nodeLetterIndex).toUpperCase()\n        ) {\n          isEqual = false;\n        }\n        indexToAdd += 1;\n      }\n      if (isEqual) {\n        gridNodes[gridNodeIndex].visited = true;\n        if (\n          verifyWord(\n            gridNodes[gridNodeIndex].adjacencyList,\n            dictionary[wordIndex],\n            0 + indexToAdd,\n            gridNodes\n          )\n        ) {\n          foundWords.push(dictionary[wordIndex]);\n        }\n        gridNodes[gridNodeIndex].visited = false;\n      }\n    }\n  }\n  return foundWords;\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport RandomGrid from './create_random_grid.js';\nimport { findAllSolutions } from './boggle_solver';\nimport { Button, Card, ButtonToolbar } from 'react-bootstrap';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport all_words from './full-wordlist';\n\nclass PrintGrid extends React.Component {\n  render() {\n    const grid_data = this.props.grid;\n    return (\n      <Card className=\"text-center\">\n        <Card.Body>\n          <Card.Title> Make words from the grid below </Card.Title>\n          <Card.Text>\n            <div class=\"btn-group\">\n              <ButtonToolbar>\n                <Button variant=\"outline-secondary\">{grid_data[1][0]}</Button>\n                <Button variant=\"outline-secondary\">{grid_data[1][1]}</Button>\n                <Button variant=\"outline-secondary\">{grid_data[1][2]}</Button>\n                <Button variant=\"outline-secondary\">{grid_data[1][3]}</Button>\n                <Button variant=\"outline-secondary\">{grid_data[1][4]}</Button>\n              </ButtonToolbar>\n            </div>\n            <br />\n            <div class=\"btn-group\">\n              <ButtonToolbar>\n                <Button variant=\"outline-secondary\">{grid_data[2][0]}</Button>\n                <Button variant=\"outline-secondary\">{grid_data[2][1]}</Button>\n                <Button variant=\"outline-secondary\">{grid_data[2][2]}</Button>\n                <Button variant=\"outline-secondary\">{grid_data[2][3]}</Button>\n                <Button variant=\"outline-secondary\">{grid_data[2][4]}</Button>\n              </ButtonToolbar>\n            </div>\n            <br />\n            <div class=\"btn-group\">\n              <ButtonToolbar>\n                <Button variant=\"outline-secondary\">{grid_data[3][0]}</Button>\n                <Button variant=\"outline-secondary\">{grid_data[3][1]}</Button>\n                <Button variant=\"outline-secondary\">{grid_data[3][2]}</Button>\n                <Button variant=\"outline-secondary\">{grid_data[3][3]}</Button>\n                <Button variant=\"outline-secondary\">{grid_data[3][4]}</Button>\n              </ButtonToolbar>\n            </div>\n            <br />\n            <div class=\"btn-group\">\n              <ButtonToolbar>\n                <Button variant=\"outline-secondary\">{grid_data[4][0]}</Button>\n                <Button variant=\"outline-secondary\">{grid_data[4][1]}</Button>\n                <Button variant=\"outline-secondary\">{grid_data[4][2]}</Button>\n                <Button variant=\"outline-secondary\">{grid_data[4][3]}</Button>\n                <Button variant=\"outline-secondary\">{grid_data[4][4]}</Button>\n              </ButtonToolbar>\n            </div>\n          </Card.Text>\n        </Card.Body>\n      </Card>\n    );\n  }\n}\n\nclass PrintList extends React.Component {\n  render() {\n    const print_words = this.props.print_words;\n    const print_items_list = print_words.map(print_item => (\n      <li>{print_item}</li>\n    ));\n    return (\n      <div>\n        <p> {this.props.valid_invalid} words list: </p>\n        <ul> {print_items_list} </ul>\n      </div>\n    );\n  }\n}\n\nclass GamePlay extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      grid: this.props.random_grid,\n      grid_solutions: this.props.random_grid_solutions,\n      input_word: '',\n      valid_words: [],\n      invalid_words: [],\n      ongoing: true\n    };\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n    this.handleStop = this.handleStop.bind(this);\n  }\n\n  handleChange(event) {\n    this.setState({ input_word: event.target.value });\n  }\n\n  handleStop(event) {\n    event.preventDefault();\n    this.setState({ ongoing: false });\n  }\n\n  handleSubmit(event) {\n    event.preventDefault();\n\n    let input_word = this.state.input_word.toLowerCase();\n    if (this.state.grid_solutions.has(input_word)) {\n      if (this.state.valid_words.includes(this.state.input_word)) {\n        alert('The word has already been found.');\n      } else {\n        var new_valid_words = this.state.valid_words;\n        new_valid_words.push(this.state.input_word);\n        this.setState({ valid_words: new_valid_words });\n        var remaining_words = this.state.grid_solutions;\n        remaining_words.delete(this.state.input_word);\n        this.setState({ grid_solutions: remaining_words });\n      }\n    } else {\n      alert('The word is not valid.');\n      var new_invalid_words = this.state.invalid_words;\n      new_invalid_words.push(this.state.input_word);\n      this.setState({ validated_word: new_invalid_words });\n    }\n  }\n\n  render() {\n    // Maybe add some check to see if grid is alreay there to prevent\n    // getting new grid everytime\n    console.log(this.state.grid);\n    console.log(this.state.input_word);\n    console.log(this.state.valid_words);\n    if (this.state.ongoing) {\n      return (\n        <Card>\n          <PrintGrid grid={this.state.grid} />\n          <br />\n          <div class=\"container\">\n            <div class=\"row\">\n              <div class=\"col-md\">\n                <form onSubmit={this.handleSubmit}>\n                  <label>\n                    Enter a word:\n                    <input\n                      type=\"text\"\n                      value={this.state.input_word}\n                      onChange={this.handleChange}\n                    />\n                  </label>\n                  <input class=\"btn btn-primary\" type=\"submit\" value=\"Submit\" />\n                </form>\n              </div>\n              <div class=\"col-md\">\n                <Button\n                  onClick={this.handleStop}\n                  type=\"button\"\n                  class=\"btn btn-primary btn-lg\"\n                >\n                  Stop\n                </Button>\n              </div>\n            </div>\n          </div>\n          <PrintList\n            print_words={this.state.valid_words}\n            valid_invalid={'Valid'}\n          />\n        </Card>\n      );\n    } else {\n      return (\n        <div>\n          <PrintGrid grid={this.state.grid} />\n          <PrintList\n            print_words={this.state.valid_words}\n            valid_invalid={'Valid'}\n          />\n          <PrintList\n            print_words={this.state.invalid_words}\n            valid_invalid={'Invalid'}\n          />\n          <PrintList\n            print_words={Array.from(this.state.grid_solutions)}\n            valid_invalid={'Remaining correct'}\n          />\n        </div>\n      );\n    }\n  }\n}\n\nclass Game extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { show_grid: false };\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleSubmit(event) {\n    this.setState({ show_grid: true });\n    event.preventDefault();\n  }\n\n  render() {\n    console.log(this.state.show_grid);\n    if (this.state.show_grid) {\n      const random_grid = RandomGrid();\n      var random_grid_solutions = findAllSolutions(\n        random_grid,\n        all_words.words\n      );\n      var random_grid_solutions_set = new Set(random_grid_solutions);\n      console.log('Random grid solutions: ', random_grid_solutions_set);\n      console.log(random_grid);\n      return (\n        <div>\n          <Card className=\"text-center\">\n            <Card.Header>Boggle</Card.Header>\n            <Card.Body>\n              <GamePlay\n                random_grid={random_grid}\n                random_grid_solutions={random_grid_solutions_set}\n              />\n            </Card.Body>\n          </Card>\n        </div>\n      );\n    } else {\n      return (\n        <div>\n          <Card className=\"text-center\">\n            <Card.Header>Boggle</Card.Header>\n            <Card.Body>\n              <Card.Title> Click below to start playing boggle </Card.Title>\n              <Button onClick={this.handleSubmit} variant=\"primary\">\n                Start\n              </Button>\n            </Card.Body>\n          </Card>\n        </div>\n      );\n    }\n  }\n}\n\nReactDOM.render(<Game />, document.getElementById('root'));\n"],"sourceRoot":""}